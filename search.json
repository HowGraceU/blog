[{"title":"跨域资源共享的种方法","url":"/2019/02/24/cross-domain-methiod/","content":"\n**最近学习过程中，听到（还是看到）有人说，看懂了不是真的会。看懂了，记下来并能够把别人讲懂才是真的会。**\n**看完之后感触颇深，决定将之后学习全部做一个记录，来检验自己是否理解细节。今天就从老生常谈的跨域方法开始。**\n\n### 1. img 标签跨域\n\n**并非 img 标签，所有的带属性 src 可以请求到不同源的资源，并且可以在url里面加上queryString向后台发送数据。**\n\n``` js\n// URL末尾带上了 ?name=jqx，传了name字段到后台\n<img  crossOrigin=\"anonymous\" id=\"tulip\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=489343535,3713603063&fm=58?name=jqx\" alt=\"The Tulip\" />\n```\n\n### 2. img 标签跨域\n\n**为什么第二个还是 img 标签跨域？是不是作者糊涂了？其实不然。**\n\n**图片和 base64 之间可以相互转换，所以就有人往上面动歪脑筋了，想出了花里胡哨（sang xin bing kuang）的办法。将数据放在图片里面，前端拿到图片之后，利用 canvas 可以拿到图片的 base64 数据。**\n\n**注意：跨域的图片想要利用 canvas 转成 base64 数据，需要在img和后台添加跨域支持（与 ajax 跨域类似）**\n\n``` js\n<img  crossOrigin=\"anonymous\" id=\"tulip\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=489343535,3713603063&fm=58?name=jqx\"/>\n\n<canvas id=\"myCanvas\"></canvas>\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nvar img=document.getElementById(\"tulip\");\n\nctx.drawImage(img, 10, 10);\nconsole.log(myCanvas.toDataURL());\n```\n\n### 3. jsonp 跨域\n\n**jsonp 跨域的道理与 img 方法有相同，也有不同的地方。**\n\n**相同的地方是，利用 script 标签的 src 属性，将自己定义好的回调函数传给后台，与 img 一样发起一个 GET 请求。**\n\n**不相同的是，img 标签拿到返回的数据之后会渲染图片，而 script 标签拿到返回数据之后，会运行返回的 js 代码，而代码的内容，就全权交由后台掌控了。**\n\n### 4. document.domain 跨 cookie\n\n**在跨域情况下，各个网页的 cookie 是无法共享的，但是如果两者的一级域名（至少是一级域名）相同的情况下，通过设置 cookie 的 domain 使得两个网页的 cookie 数据是可以共享的。**\n\n**正常情况下的 cookie**\n![domain1](../../../../img/cross-domain-methiod/domain1.png)\n\n**设置了 domain 的cookie**\n![domain2](../../../../img/cross-domain-methiod/domain2.png)\n\n``` js\n// www.baidu.com\ndocument.cookie = 'name=jqx;domain=.baidu.com'\n\n// news.baidu.com\ndocument.cookie\n// name=jqx;\n```\n\n**不过一般情况下，都会从后台来控住 cookie domain 值**\n\n``` js\nSet-Cookie: name=jqx; domain=.baidu.com\n```\n\n### 5. 父子页面 location.hash\n\n**针对使用 iframe 或者 window.open 打开了不同源的网页，两者之间不能进行访问的情况。**\n\n**在提前知道对方的url的情况下，父子页面可以相互修改 hash 值来进行传值。**\n\n``` js\n// iframe 打开子页面\n// 父页面  http://192.168.0.112:8000/A.html\n<iframe id=\"myIframe\" name=\"myIframe\" src=\"http://192.168.0.112:8002/B.html\" frameborder=\"0\"></iframe>\n\nlet myIframe = document.getElementById('myIframe');\nmyIframe.src = `${myIframe.src}#jqx`\n\n// 子页面 http://192.168.0.112:8002/B.html\n// 因无法访问父页面，所以需先知道父页面的 url\nlet parentUrl = 'http://192.168.0.112:8000/A.html';\nparent.location.href = `${parentUrl}#jqx`\n\n// 使用 window.open 方式打开子页面\n// 父页面  http://192.168.0.112:8000/A.html\nlet childUrl = 'http://192.168.0.112:8002/B.html';\nlet childWindow = window.open(childUrl);\nchildWindow.location.href = `${childUrl}#jqx`\n\n// 子页面 http://192.168.0.112:8002/B.html\nlet parentUrl = 'http://192.168.0.112:8000/A.html';\nwindwo.opener.location.href = `${parentUrl}#jqx`\n```\n\n### 6. 父子页面 window.name\n**window.name 属性，只要在用一窗口里，前一个网页设置了这个属性，后一个网页也可以读取他。**\n\n**当父页面打开不同源的子页面，子页面可以将数据转成字符串存在 window.name 属性中，存完后再使用 location.herf 跳转到与父同源的页面，父页面就可以通过子页面的 window.name 属性拿到数据。**\n\n**这种方法局限性很大，无法及时得知子页面的 name 的变化（无监听API），且子页面返回一次数据后页面就被销毁。**\n\n### 7. 父子页面 window.postMessage\n**H5 提供了新 [postMessage API](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) 来帮助不同源的父子页面进行更方便的交互。**\n\n``` js\n// iframe 打开子页面\n// 父页面  http://192.168.0.112:8000/A.html\n<iframe id=\"myIframe\" name=\"myIframe\" src=\"http://192.168.0.112:8002/B.html\" frameborder=\"0\"></iframe>\n\nlet myIframe = document.getElementById('myIframe');\nmyIframe.addEventListener('load', () => {\n    myIframe.contentWindow.postMessage({a: 1}, 'http://192.168.0.112:8002');\n})\n\nwindow.addEventListener('message', e => {\n    console.log(`B data: ${e.data}`);\n})\n\n// 子页面 http://192.168.0.112:8002/B.html\nwindow.addEventListener('message', (e) => {\n    let {origin, data, source} = e;\n    console.log(`message from : ${origin}`);\n    console.log(`data : ${JSON.stringify(data)}`);\n    source.postMessage('receive', 'http://192.168.0.112:8000');\n}, false)\n```\n\n**输出**\n![postMessage](../../../../img/cross-domain-methiod/postMessage.png)\n\n**其中 postMessage 方法第一个参数代表需要传输的数据，第二个方法代表希望传输的目标源。**\n\n**目标页面在 window 上绑定 message 事件后，待父页面发送数据触发页面。event 对象中有代表数据来源的 origin，代表数据的 data，代表来源 window 的 source。可以通过 source 通道反向传数据。**\n\n### 8. form表单跨域\n**form 表单的提交是没有跨域限制的，因为表单的提交之后没法在不同源的页面拿到返回的数据，所以浏览器认为这是相对安全的请求。**\n**BTW，所有的跨域请求其实都返回了，只是浏览器限制了 js 获取响应，所以导致了跨域问题。**\n**form 表单可以跨域提交，并且将返回的数据写入指定的 iframe 中，再利用 iframe 之间的资源共享方案（5，6，7），还是有办法拿到数据的。**\n\n``` js\n<form name=\"login\" action=\"http://192.168.0.112:3000/login\" method=\"POST\" enctype=\"multipart/form-data\" target=\"login-iframe\">\n    <label for=\"name\">name</label>\n    <input name=\"name\" type=\"text\" value=\"jqx\">\n    <label for=\"password\">password</label>\n    <input name=\"password\" type=\"password\" value=\"12345678\">\n    <button>提交</button>\n</form>\n\n<iframe name=\"login-iframe\" src=\"\" frameborder=\"0\" width=\"500\" height=\"500\"></iframe>\n```\n\n![form提交](../../../../img/cross-domain-methiod/form.png)\n\n### 9. CORS\n**主流的跨源资源分享解决方法。**\n**使用 ajax 请求不同源页面资源，可以直接操作返回的数据，需要后台添加请求头。[CORS MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)描述得非常详细。**\n**需要注意的是，CORS 有简单请求和非简单请求之分，而非简单请求时，会先向后台发送一个 OPTION 请求，之前还碰到非简单请求的坑。猛戳[博客](../../../..//2018/08/29/axios-CORS/)**\n\n### 10. WebSocket\n**WebSocket 是一个新协议，实现了客户端和服务端之间的全双工、实时、并发交互数据。**\n**因为是一个全新的协议，所以浏览器在请求数据的时候就已经跨域了。服务端能通过请求头里面的 origin 字段来判断浏览器是否在白名单。**\n\n**以上全个人见解**","tags":["cross-domain"]},{"title":"array的长度大于10时，sort的行为","url":"/2018/10/25/arrSort/","content":"\n### 函数返回布尔时，排序不正常\n\n**同事说遇到了一个奇怪的bug，找我一起看，他的代码**\n\n``` js\nvar arr = [1,3,2,4,5,8,6,9,11,7,0];\n\narr.sort((a, b) => a > b);\n// [8, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11]\n```\n\n**wft！这有点颠覆我对js的认识啊，于是自己进行了测试，发现怎么测试结果都是正常的从小到大排序**\n\n**仔细查阅了mdn文档以及网上的资料发现，例子中的返回值都是以大于0，小于0和0来区别，并且数组长度大于10和小于等于10时，处理方法不一样。在大于10时，浏览器使用了一种快排的方法对数组进行排序，小于10时则是冒泡排序。**\n\n### 快排时会出现问题\n\n**于是进行进一步测试，当数组长度大于10时，果然数组的排序不尽如人意。似乎是快排的时候出了问题，于是翻了一下[github上V8项目中快排的代码](https://github.com/v8/v8/blob/master/src/js/array.js)，发现代码中的使用了 >= 来判断是否需要交换位置。所以返回false会使得if成立，而返回小于0则不会。**\n\n![V8快排](../../../../img/arrSort/V8QS.png)\n\n**综上，在sort的函数中，始终返回数值类型而不返回布尔类型就可以避免出现bug。**\n\n### 浏览器新版本支持度\n\n**顺便一提，测试时发现，在新版本的谷歌之中（70）和edge（17），不会处理返回布尔类型的情况。不管是冒泡还是快排。**\n``` js\nvar arr = [1,3,2,4,5,8,6,9];\n\narr.sort(function(a, b) {return a > b});\n// [1, 3, 2, 4, 5, 8, 6, 9]\n```\n\n### 快排算法\n\n**最后附上阮大大的对[快排](http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html)算法详细解释的文章**","tags":["v8"]},{"title":"node 循环引用","url":"/2018/09/14/node-cyclic/","content":"\n**近期在node开发的过程中，碰到require文件后，无法调用文件内定义的方法，翻阅资料怀疑是循环引用，于是自己进行了测试。**\n\n## 循环引用测试\n\n**a.js**\n``` js\nconsole.log('at a.js');\nvar b = require('./b');\n\nexports.test = \"i'm a\";\n\nsetImmediate(() => {\n    console.log(`get b.test ${b.test}`);\n})\n```\n\n**b.js**\n``` js\nconsole.log('at b.js');\nvar a = require('./a');\n\nmodule.exports = {\n    test: \"i'm b\"\n}\n\nsetImmediate(() => {\n    console.log(`get a.test ${a.test}`);\n})\n```\n\n**测试结果如下**\n``` js\nnode .\\a.js\n\nat a.js\nat b.js\nget a.test i'm a\nget b.test i'm b\n\nnode .\\b.js\n\nat b.js\nat a.js\nget b.test undefined\nget a.test i'm a\n```\n\n**运行b.js的时候，当运行到 require('./a') 的时候，去加载a.js的代码，而a.js里又 require('./b')，这里导致了循环引用。**\n\n**但是这里并不会进入死循环，原因是node在require的时候发现内存里已经存在这个模块的引用，则返回引用而不会重新去运行这个模块的代码。**\n\n**node .\\a.js的时候，require('./b')，而a.js停留在 var b = require('./b');，此时在b.js 得到的a模块的内容为a的module.exports {}。在运行完b.js之后，又在a的module.exports对象上加上属性，所以b中延迟打印出来的a的属性存在。**\n\n**而node .\\b.js的时候，require('./a')，b.js停留在var a = require('./a');，此时还没有运行module.exports = { test: \"i'm b\" }，得到b模块的内容为b的module.exports {}，运行完a之后，执行 module.exports = ... 代码，将module.exports指向了另一个对象，而缓存中b模块的内容则是之前引用的b的module.exports，所以b的test属性并没有加在b模块在内存中的对象上，所以之后再有require('./b')拿到的都是空对象 {}**\n\n## 避免循环引用产生的问题\n\n*   尽量不使用module.exports重置模块的引用。\n*   非要使用module.exports，module.exports应该放在js的开头，即其他逻辑之前。\n\n### 题外：在查node循环引用问题时，看到一个知名搜索引擎上较为靠前的博客有点问题。\n\n**以下为文中的测试代码**\n``` js\na.js\n\nconsole.log('a.js');\nvar b = require('./b');\nconsole.log('a+.js');\nconsole.log(b);\nexports={name:'a'};\nconsole.log('a++.js');\n\n\nb.js\n\nconsole.log('b.js');\nvar c = require('./a');\nconsole.log('b+.js');\nconsole.log(c);\nexports={name:'b'};\nconsole.log('b++.js');\n```\n\n**测试结果中，模块a和模块b都是 {}**\n**这个代码不管怎么改，打印出来的结果都是 {}，因为在node中 exports={name:'a'}; 无法用来暴露变量。原因如下**\n\n``` js\n(function (exports, require, module, __filenam, __dirname) {\n    ...文件中代码\n})\n```\n**代码来自《深入浅出nodejs》，上述代码的是在每一次用node运行js脚本的时候，都会运行上述函数来执行脚本中的代码，而脚本中使用的exports、module都只是这个函数中的一个局部变量。当你运行 exports={name:'a'}; 时，不过改变这个函数作用域中，局部变量的指向，而非改变 module.exports 所指向的对象中的属性。**","tags":["moudle"]},{"title":"axios跨域请求报错","url":"/2018/08/29/axios-CORS/","content":"\n**在一个开发web桌面应用的项目中，使用了axios向服务器发送请求，结果报了跨域请求的错误。页面代码大致如下：**\n\n``` js\n<script src=\"./node_modules/axios/dist/axios.js\"></script>\n<script>\n        axios.post('http://127.0.0.1:3000/getDate', {\n            a: 1\n        });\n</script>\n```\n\n![跨域报错](../../../../img/axios-CORS/1.png)\n\n**反复查看后台代码，明明是已经加上了跨域的头部Access-Control-Allow-Origin，可是还是请求失败。**\n**代码倒是看不出任何问题，于是猜想是axios内部框架做了什么鬼祟，使用原生的XHR对象进行调试。**\n\n![原生XHR跨域](../../../../img/axios-CORS/2.png)\n\n**果然请求到了，并且看到返回头里面带上了允许跨域头。仔细比对两次请求发现，axios发的请求的method竟是OPTIONS，这是什么，html难道不是只有GET，POST吗！？翻查[http mdn](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)**\n\n## xhr跨域请求\n\n**出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。以下三种情况下跨域请求的结果皆不相同。**\n\n### 简单请求\n\n**某些请求不会触发 CORS 预检请求。若请求满足所有下述条件，则该请求可视为“简单请求”：**\n\n*   **使用下列方法之一：**\n    *   GET\n    *   HEAD\n    *   POST\n*   **Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：**\n    *   Accept\n    *   Accept-Language\n    *   Content-Language\n    *   Content-Type （需要注意额外的限制）\n    *   DPR\n    *   Downlink\n    *   Save-Data\n    *   Viewport-Width\n    *   Width\n*   **Content-Type 的值仅限于下列三者之一：**\n    *   text/plain\n    *   multipart/form-data\n    *   application/x-www-form-urlencoded\n*   **请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。（文件上传对象）**\n*   **请求中没有使用 ReadableStream 对象。**\n\n### 预检请求\n**简单来说，请求不满足简单请求规范，则为预检请求。预检请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。**\n\n**从文章开头的例子中可以看出我们的OPTIONS是一个预检请求，应该是由axios发送跨域请求的时候进行了头部的设置导致。从OPSTIONS的抓包上看，请求头里面倒是有需要预检的首部字段。**\n\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type \n\n// 服务器端应加上\nAccess-Control-Allow-Methods: POST //简单请求允许method，可不带\nAccess-Control-Allow-Headers: Content-Type\n```\n\n**看来是axios将请求头进行了设置导致跨域失败，进入axios源码查看，哪里进行了配置。进入源码查询发现axios在参数为json对象时，设置了content-type为application/json;charset=utf-8**\n\n![axios源码](../../../../img/axios-CORS/3.png)\n\n### 解决方案一：修改请求头\n\n**一种解决方法是axios设置默认头部**\n\n``` js\n<script src=\"./node_modules/axios/dist/axios.js\"></script>\n<script>\n        let config = {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            }\n        };\n\n        axios.post('http://127.0.0.1:3000/getDate', {\n            a: 1\n        }, config);\n</script>\n```\n\n### 解决方案二：服务端添加预检支持\n\n**这毕竟是一个跨域资源，是多人共享的资源，不能保证每个人请求头都属于简单请求，所以应该在服务器端对预检请求添加支持。**\n\n``` js\n// 这里以koa为例\nconst Koa = require('koa');\nconst Router = require('koa-router');\n\nconst app = new Koa();\nvar router = new Router();\n\nrouter\n  .get('/', (ctx, next) => {\n    ctx.body = 'Hello World!';\n  })\n  .post('/getDate', (ctx, next) => {\n    ctx.set('Access-Control-Allow-Origin', '*');\n    ctx.set('Access-Control-Allow-Headers', 'Content-Type');\n    ctx.response.type = 'json';\n    ctx.response.body = { data: 'Hello World' };\n  })\n\napp\n  .use(router.routes())\n  .listen(3000);\n```\n\n**加上响应头之后，理应能够自定义content-type的值，且成功跨域才对。可是跑最开始的跨域请求却出现404**\n\n![OPTIONS请求404](../../../../img/axios-CORS/4.png)\n\n**竟然是404，一顿推理，妄加猜测，应是服务器没有路径为/getDate，method 为 OPTIONS 的路由，在服务器端加上路由。**\n\n``` js\nrouter\n  .options('/getDate', (ctx, next) => {\n    ctx.set('Access-Control-Allow-Origin', '*');\n    ctx.set('Access-Control-Allow-Headers', 'Content-Type');\n    ctx.response.body = 'allow';\n  })\n```\n\n**加上后自定义头部的跨域请求也可以正常跨域了**\n\n![预检请求OPTOINS](../../../../img/axios-CORS/5.png)\n\n![预检请求POST](../../../../img/axios-CORS/6.png)\n\n**由上面2图可以看出，预检跨域请求，浏览器会发送2个请求到服务器端，一个是OPTIONS预检，一个是POST请求，产生2条抓包。**\n\n</br>\n### 题外：跨域资源共享标准 （有些不常用，mark一下）\n\n**跨域资源共享标准（ [cross-origin sharing standard](http://www.w3.org/TR/cors/) ）允许在下列场景中使用跨域 HTTP 请求：**\n\n*   **XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。**\n*   **Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。**\n*   **WebGL 贴图**\n*   **使用 drawImage 将 Images/video 画面绘制到 canvas**\n*   **样式表（使用 CSSOM）**\n*   **Scripts (未处理的异常)**","tags":["CORS"]},{"title":"hello world","url":"/2018/08/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["blogTest"]},{"title":"常见的内存泄露和排查","url":"/2018/08/23/leak&debugger/","content":"# 内存泄露\n\n## 什么是内存泄露\n\n本质上来讲，内存泄露是当一块内存不再被应用程序使用的时候，由于某种原因没有返还给操作系统或者空闲内存池的现象。\n\n## js的内存管理\n\njs中的垃圾回收机制，会周期性地检查之前被分配出去的内存是否可以从应用的其他部分访问。换句话说，什么样的内存仍然可以从应用程序的其他部分访问，不可访问的内存可以通过算法确定并标记以便返还给操作系统。\n\n# 常见4种的内存泄露\n\n1.  意外的全局变量\n\n``` js\n/* 例子1 */ \nfunction foo () {\n    bar = 'a hidden global variable';\n}\n\n/* 例子2 */ \nfunction foo () {\n    this.bar = 'a global variable';\n}\n\nfoo()\n```\n\n##### 全局变量注意事项\n\n如果你必须使用全局变量来存储很多的数据，请确保在使用过后将它设置为null。\n\n2.  监听\n\n``` js\nvar el = ducumemt.getElementById('a');\n\nvar onClick = () => {\n    el.innerText = 'text';\n}\n\nel.addEventListener('click', onClick);\n\nel.removeEventListener('click', onClick);\nel.parentNode.removeChild(el);\n```\n\ndom节点和js代码之间的循环引用，在ie老版本上会有内存泄露bug。大部分类库在废弃一个节点之前，会移除listener。目前，现代浏览器（包括IE）都能发现这些循环引用并正确回收，在废弃一个节点之前调用removeEventListener不再是必要的操作。\n\n3.  DOM引用\n\n``` js\n<div id='a'>\n    <div id='b'></div>\n<div>\n\nvar divB = document.getElementById('b');\ndocument.body.removeChild(document.getElementById('a'));\n```\n\njs代码中保留了子元素的特定引用，然后移除父辈元素div#a，表面上看整个元素都被移除了，但是在内存中还保留着对div#a的引用。因为div#b保留着对父辈的引用，导致整个div#a都保留在内存中。\n\n4.  闭包\n\n``` js\n/* 代码一 */ \nvar obj = null;\nvar replaceObj = () => {\n    var oldObj = obj;\n    obj = {\n        memory: new Array(1000000).join('*'),\n        closeFn () {\n            console.log(123);\n        }\n    };\n    oldObj && oldObj.closeFn();\n}\n\nsetInterval(replaceObj, 1000);\n```\n上述代码调用结果如下图\n\n![无闭包时函数调用](../../../../img/leak&debugger/1.jpg)\n\n断点进函数查看，并没有闭包引用，并且打印稳定1秒钟1个\n\n正常时候的内存情况为下图\n\n![正常内存](../../../../img/leak&debugger/2.jpg)\n\n---\n分割线\n___\n\n``` js\n/* 代码二 */\nvar obj = null;\nvar replaceObj = () => {\n    var oldObj = obj;\n    obj = {\n        memory: new Array(1000000).join('*'),\n        closeFn () {\n            /* 将函数调用移至闭包内 */\n            if (oldObj) {\n                console.log('hi')\n            }\n            console.log(123);\n        }\n    };\n    oldObj && oldObj.closeFn();\n    console.log('---------------------');\n}\n\nsetInterval(replaceObj, 1000)\n```\n\n上述代码调用结果如下图\n\n![有闭包时控函数调用](../../../../img/leak&debugger/4.jpg)\n\n断点进函数查看，函数内部存在闭包引用，每次创建的新对象都会引用上一个对象，导致每次创建的对象都不被GC回收。因为闭包引用而导致对象没有被回收，熟练使用谷歌调试也可以查出来,重点看代码三。\n\n---\n分割线\n___\n\n``` js\n/* 代码三 */\nvar obj = null;\nvar replaceObj = () => {\n    var oldObj = obj;\n\n    var unused = () => {\n        if (oldObj) {\n            console.log('hi')\n        }\n    }\n\n    obj = {\n        memory: new Array(1000000).join('*'),\n        closeFn () {\n            console.log(123);\n        }\n    };\n}\n\nsetInterval(replaceObj, 1000)\n```\n\n上述代码因为不能在闭包里面打印，所有用谷歌调试工具抓内存查看\n\n文中代码在浏览器中运行时的内存情况\n\n![文中代码内存情况](../../../../img/leak&debugger/5.jpg)\n\n导致内存泄露的原因是在同一个父作用域下创建闭包时，这个作用域是共享的。代码中closeFn的闭包作用域和unused的闭包作用域是共享的。即便unused函数从未被使用且不可能被使用，它对oldObj的引用造成了oldObj的活跃（阻止它被回收）。代码三中closeFn拥有的闭包与代码二中closeFn拥有的闭包相同。\n\n#   devTools调试\n\n##  Profiles视图\n\n在老版本谷歌上显示为Profiles，新版本谷歌改名为Menory，文中使用谷歌版本69。该功能可以对js内存进行快照，也可以记录一段时间内的内存分配情况，如下图。\n\n![快照、录像](../../../../img/leak&debugger/6.jpg)\n\n以上文代码三内存泄露为例，\n\n1.  快照\n\n快照中summary视图提供了不同类型的分配对象以及他们的合计大小。shallow size表示一个特定类型所有对象总和，retained size表示此对象的shallow size和保留此对象的其他对象的shallow size总和，distance表示对象到GC根（最初引用的那块内存）的最短距离。\n\n![快照](../../../../img/leak&debugger/7.jpg)\n\n图中的字符串的shallow size等于retained size，大概因为字符串不是引用类型。\n字符串上面的closeFn函数的shallow size只有56，二retained size的大小是3000640，是因为这个对象被其他对象引用，其他对象的总大小加上closeFn函数的shallow size得到3000640。\n图中可以看出，window的distance是1，即最接近GC根，往下的Object直接定义在window上所有distance是2，后面一层一层引用，引用得越深，distance越大。\n\n2.  对比快照\n\n快照中comparison视图提供了这一次快照与上一次快照直接的对比\n\n![快照对比](../../../../img/leak&debugger/8.jpg)\n\n这个视图里能清晰看出这一次快照与上一次快照新增，删除了多少对象。\n\n3.  录像\n\ndevTools还提供了录像功能，点击Profiles，选择第二个切换到录像。\n\n![切换录像](../../../../img/leak&debugger/9.jpg)\n\n开始录像后能清晰看到网页根据时间轴所产生的内存，可以选择某一时间段去查看其中的内存分配\n\n![录像](../../../../img/leak&debugger/10.jpg)\n\n## 参考文献\njavaScript中4种常见的内存泄露陷阱(http://web.jobbole/com/88463)\n本文全是作者对这篇文献的理解，或与原文有所不同，若有错误欢迎指出。","tags":["devtools"]},{"title":"WebRTC p2p h5 api科普","url":"/2018/07/12/h5_webrtc-h5api/","content":"# WebRTC实现网页端到网页端互看的流程及demo\n\n## - 什么是WebRTC\n\nWebRTC是网页**实时通信**（Web Real-Time Communication）的缩写，可以让网页**无需安装插件**，进行**实时**语音对话或视频对话的技术，此例实现的是网页之间实时视频通信。\n\n## 准备所需材料\n\n2台有摄像头的电脑、高版本浏览器（这里用到是谷歌65）、信令服务器（可以用node实现，也可以用sip实现，作用是把页面的生成的数据发送给对端）、https服务器（webRTC访问本地设备需要https）\n\n## WebRTC流程\n\n![WebRTC流程图](../../../../img/h5_webrtc-h5api/pc流程图.png)\n\n备注：图中Signal Server（黄色）为信令服务器，可以理解为传递数据用的后台，图中部分老规范方法已经弃用，需用新规范方法代替。\n\n1.  A端和B端与信令服务建立连接，作为之后将A，B端消息交互的通道。\n\n2.  A端调用创建WebRTC对象，传入一个参数，与打洞服务器有关。\n\n``` js\nlet pc = new RTCPeerConnection(null);\n```\n3.  A端调用 **navigator.getUserMedia** 方法获取本地流stream，给video标签设置srcObject属性即可看到本地画面，并调用 **addTrack（图中AddStreams）** 方法将流添加至通道中。\n\n``` js\n//获取本地流\n//第一个参数为分辨率限制，不需要则如下传值，第二个为成功回调，第三个为错误回调\n//由于 navigator.getUserMedia 是异步方法，可修改为同步函数\nlet getNavMedia = () => {\n  return new Promise((resolve, reject) => {\n    navigator.getUserMedia({\n      audio: true,\n      video: true\n    }, (stream) => {\n      resolve(stream);\n    }, (error) => {\n      console.log(`navigator.getUserMedia error: ${error}`);\n      resolve(error);\n    });\n  });\n};\n\nlet mediaStream = await getNavMedia();\n//设置video标签属性，显示视频\nif (mediaStream.id) {\n  myVideo.srcObject = mediaStream\n}\n\n// 在通道中添加流，图中add Streams过程\nmediaStream.getTracks().forEach(\n    function (track) {\n        pc.addTrack(\n            track,\n            mediaStream\n        );\n    };\n);\n```\n\n4.  A端调用 **createOffer** 生成offer（一个标准的sdp协议，大概包含音视频格式码流等信息），再调用 **setLocalDescription** 设置本地sdp（offer），并经过信令服务器发送至B端。\n\n``` js\n// createOffer返回一个promise，所以可以直接写成async\nlet offer = await pc.createOffer();\n\n// 或者用.then来调用，成功回调返回一个offer参数\npc.createOffer().then(successBack, errorBack);\n\n// setLocalDescription同createOffer，返回一个promise，只不过没有返回\npc.setLocalDescription(offer)\n```\n\n5.  B端接收到offer之后，调用 **setRemoteDescription** 设置远端sdp（offer），再调用 **createAnswer** 生产answer（与offer相对），调用 **setLocalDescription** 设置本地sdp（answer），并经过信令服务器发送至A端。\n\n``` js\n// setRemoteDescription, createAnswer皆返回promise\n// 这里设置远端sdp完成才能生成对应answer，\n// 否则会报错CreateAnswer can't be called before SetRemoteDescription.\nawait pc.setRemoteDescription(offer)\n\nlet answer = pc.createAnswer()\n\npc.setLocalDescription(answer)\n```\n\n6.  A端接收到answer后，调用 **setRemoteDescription** 设置远端sdp（answer）。\n``` js\npc.setRemoteDescription(answer)\n```\n\n#### 以下为RTCPeerConnection事件，应该在第二步创建之后绑上\n\n7.  第1-第6步过程中会生产icecandidate（浏览器打洞相关）数据，并且触发RTCPeerConnection对象的 **onicecandidate** 事件，这些icecandidate数据需要发送至对端，对端调用 **addIceCandidate** 添加。\n``` js\n// 产生icecandidate\npc.onicecandidate = (e) => {\n  if (e.candidate) {\n    console.log(e.candidate)\n    ...// 经过信令服务器发送至对端\n  }\n}\n\n// 接收icecandidate\npc.addIceCandidate(candidate)\n```\n\n8.  所有流程正常运行后，会触发pc的 **ontrack** 事件，并给出对端流，给video标签设置srcObject属性即可看到对端画面\n``` js\npc.ontrack = (e) => {\n  if (e.streams) {\n    //设置video标签属性，显示视频    \n    peerVideo.srcObject = e.streams[0]\n  }\n}\n```\n\n9.  **pc.onremovestream** 失去对端流事件\n\n## 项目地址\n[https://github.com/HowGraceU/WebRTC_p2p](https://github.com/HowGraceU/WebRTC_p2p) \n\n## 参考文献\nWebRTC权威指南.pdf（已上传至项目中）","tags":["WebRTC"]}]